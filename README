
Deitel's How to Program books (Java, C++, C#) have a couple exercises to emulate
the other aspects of the programming environment. The first example is the VM that
they call Simpletron. I sort of implemented it in Java some time ago, but mishandled
addressing. To incentivize learning Python, I am reimplementing it now. The second
exercise involves creating a BASIC-esque compiler to generate its machine code.

SIMPLETRON ISA:

Accumulator, IR, PC; RAM of 100 integers.

	STOP = 00
	READ = 10xx
	WRITE = 11xx
	ADD = 20xx
	SUBTR = 21xx
	MULTP = 22xx
	DIVIDE = 23xx
	GOTO = 30xx
	GOTOZERO = 31xx
	GOTONEG = 32xx
	LOAD = 40xx
xx is the address of the value to operate on. Obviously, stop is unary. The math
operations use the directed value with whatever is in the accumulator.

SIMPLE COMPILER GRAMMER:

A: D X | D C E | D I E G D
C: rem | input | let | print
D: { 0-9 } | DD
E: L | D | L O D | L O E
G: goto
I: if
L: { a-z } | LL
O: + | - | * | / | = | > | < | ==
X: end

It has been a long time, and rewriting this grammer has become tedious, but I think
that conforms. The point is that a line involves [line number] [command] [expression]
following the forms that the commands demand.

SIMPLE COMMANDS

rem - commented string
input - value from terminal
let - assign via x = expression
print - print to terminal
goto - unconditional jump
if - conditional jump, form of if [ expression ] goto [ line number ]
end - stop execution

RUNNING INSTRUCTIONS
To test cpu alone, use "comp.py [filename]", however comp needs two lines uncommented
because I've set it to run from within programmer.
To test the compiler use "testCompiler.py". For the moment, it contains a hardcoded ref to
monkey or similar. Later I will change it & programmer.py to use a file from argv (and ask if run)